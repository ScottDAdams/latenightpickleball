
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pickleball Event Maker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One:wght@400&family=Righteous&family=Bungee&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#07001a;
      --bg2:#1a0b5e;
      --bg3:#ff2bd6;
      --cyan:#22d3ee;
      --pink:#ff4fd8;
      --purple:#a855f7;
      --lime:#a3e635;
      --glass: rgba(255,255,255,0.08);
      --glass2: rgba(255,255,255,0.12);
    }
    body{
      background: radial-gradient(1200px 800px at 70% 30%, rgba(255,47,214,.18), transparent 55%),
                  radial-gradient(1000px 700px at 20% 20%, rgba(34,211,238,.12), transparent 55%),
                  linear-gradient(180deg, #0f172a 0%, #1e293b 25%, #0f172a 60%, #020617 100%);
      overflow-x:hidden;
    }
    body.highlander{
      background: url("https://www.inspiringtravelscotland.com/wp-content/uploads/2019/05/Quiraing-Skye-Scottish-Highlands.jpg") center/cover no-repeat fixed,
        radial-gradient(ellipse 100% 80% at 50% 0%, rgba(30,41,59,.85) 0%, rgba(15,23,42,.9) 35%, rgba(12,18,34,.92) 60%, rgba(2,6,23,.95) 100%);
      position: relative;
    }
    body.highlander::before{
      content: "";
      position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background: radial-gradient(ellipse 100% 100% at 50% 50%, transparent 40%, rgba(0,0,0,.4) 100%);
      opacity: .9;
    }
    body.highlander::after{
      content: "";
      position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
      opacity: .5;
    }
    body.highlander header h1{
      background: linear-gradient(180deg, #fef3c7 0%, #f59e0b 25%, #d97706 50%, #b45309 75%, #92400e 100%);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-shadow: 0 1px 0 rgba(255,255,255,.3), 0 -1px 0 rgba(0,0,0,.2);
      filter: drop-shadow(0 0 20px rgba(245,158,11,.35));
      letter-spacing: .08em;
    }
    body.highlander header #headerSubtitle{
      text-transform: uppercase; letter-spacing: .25em; color: #94a3b8;
      font-size: .85rem; margin-top: .35rem;
    }
    body.highlander header .header-rule{
      display: block; height: 1px; background: linear-gradient(90deg, transparent, rgba(212,175,55,.4), transparent);
      max-width: 320px; margin: .5rem auto 0; opacity: .8;
    }
    body.highlander .matchCard{
      background: rgba(30,41,59,.75);
      border: 1px solid rgba(212,175,55,.25);
      box-shadow: 0 0 20px rgba(212,175,55,.08), 0 10px 25px rgba(0,0,0,.4);
      backdrop-filter: blur(12px);
    }
    body.highlander .matchCard .courtTitle{
      color: #fcd34d;
      text-shadow: 0 0 12px rgba(252,211,77,.3);
      font-variant: small-caps;
      font-size: .9rem;
    }
    body.highlander #leaderboardPanel{
      background: rgba(15,23,42,.85);
      border: 1px solid rgba(212,175,55,.2);
      box-shadow: 0 0 18px rgba(0,0,0,.3);
    }
    body.highlander #leaderboardPanel .leaderboard-row{ border-bottom: 1px solid rgba(212,175,55,.15); }
    body.highlander #leaderboardPanel .leaderboard-row.tied-leader{ box-shadow: 0 0 14px rgba(252,211,77,.12); }
    body.highlander #leaderboardPanel .wins-num{ font-weight: bold; color: #fcd34d; }
    body.highlander #winnerOverlay{
      background: radial-gradient(ellipse 100% 100% at 50% 30%, #1e293b 0%, #0f172a 40%, #020617 100%);
    }
    #winnerOverlay{
      padding: 1rem; box-sizing: border-box; overflow: auto;
      justify-content: center; align-items: center; flex-wrap: wrap; gap: 0.5rem;
    }
    #winnerOverlay h1{ font-size: clamp(1.5rem, 6vw, 3.75rem); margin-bottom: clamp(0.5rem, 2vw, 1.5rem); line-height: 1.2; }
    #winnerOverlay #winnerName{ display: block; font-size: clamp(1.25rem, 5vw, 3rem); margin-top: 0.25em; }
    #winnerOverlay #winnerSubtitle{ font-size: clamp(0.875rem, 2.5vw, 1.25rem); margin-bottom: clamp(0.5rem, 1.5vw, 1rem); }
    #winnerOverlay #finalLeaderboard{ font-size: clamp(0.875rem, 2vw, 1.875rem); max-height: 50vh; overflow: auto; }
    #winnerOverlay #finalLeaderboard.finalLeaderboard-cols-2{ column-count: 2; column-gap: 2rem; column-fill: balance; }
    #winnerOverlay #finalLeaderboard.finalLeaderboard-cols-3{ column-count: 3; column-gap: 1.5rem; column-fill: balance; }
    body.highlander #winnerOverlay .winner-name-cinematic{
      background: linear-gradient(180deg, #fef3c7, #f59e0b);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      text-transform: uppercase; letter-spacing: .1em;
      filter: drop-shadow(0 0 24px rgba(245,158,11,.5));
    }
    /* Highlander button theme: dark slate + gold, readable */
    body.highlander .neonBtn{
      background: rgba(30,41,59,.95);
      border: 1px solid rgba(212,175,55,.45);
      color: #fef3c7;
      box-shadow: 0 4px 14px rgba(0,0,0,.35), 0 0 12px rgba(212,175,55,.1);
    }
    body.highlander .neonBtn:hover:not(:disabled){
      background: rgba(51,65,85,.95);
      border-color: rgba(212,175,55,.65);
      box-shadow: 0 6px 18px rgba(0,0,0,.4), 0 0 16px rgba(252,211,77,.2);
      color: #fff;
    }
    body.highlander .neonPrimary{ background: linear-gradient(135deg, #b45309, #92400e); border-color: rgba(212,175,55,.5); color: #fef3c7; }
    body.highlander .neonPrimary:hover:not(:disabled){ background: linear-gradient(135deg, #d97706, #b45309); color: #fff; }
    body.highlander .neonWarn{ background: linear-gradient(135deg, #991b1b, #7f1d1d); border-color: rgba(248,113,113,.4); color: #fecaca; }
    body.highlander .neonWarn:hover:not(:disabled){ background: linear-gradient(135deg, #b91c1c, #991b1b); color: #fff; }
    body.highlander .neonGo{ background: linear-gradient(135deg, #166534, #14532d); border-color: rgba(134,239,172,.35); color: #d1fae5; }
    body.highlander .neonGo:hover:not(:disabled){ background: linear-gradient(135deg, #15803d, #166534); color: #fff; }
    body.highlander .neonAlt{ background: rgba(51,65,85,.95); border-color: rgba(148,163,184,.4); color: #e2e8f0; }
    body.highlander .neonAlt:hover:not(:disabled){ background: rgba(71,85,105,.95); border-color: rgba(212,175,55,.4); color: #fef3c7; }
    body.highlander .winner-button{
      background: linear-gradient(135deg, #166534, #14532d) !important;
      border-color: rgba(212,175,55,.5) !important;
      color: #d1fae5 !important;
      box-shadow: 0 0 14px rgba(34,197,94,.35) !important;
    }
    #bgFX{
      position: fixed;
      inset: 0;
      pointer-events:none;
      z-index:0;
    }
    #bgFX::before{
      content:"";
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.03) 0px,
        rgba(255,255,255,0.03) 1px,
        transparent 3px,
        transparent 7px
      );
      opacity:.35;
      mix-blend-mode: overlay;
    }
    #bgFX::after{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 55% 55%,
          rgba(255,120,60,.10) 0%,
          rgba(255,47,214,.22) 12%,
          rgba(255,47,214,.10) 24%,
          transparent 38%
        ),
        linear-gradient(to bottom,
          transparent 0%,
          transparent 52%,
          rgba(255,47,214,.10) 58%,
          rgba(34,211,238,.07) 62%,
          rgba(0,0,0,.35) 78%,
          rgba(0,0,0,.55) 100%
        ),
        repeating-linear-gradient(to right,
          rgba(34,211,238,.12) 0px,
          rgba(34,211,238,.12) 1px,
          transparent 70px,
          transparent 120px
        ),
        repeating-linear-gradient(to bottom,
          rgba(34,211,238,.10) 0px,
          rgba(34,211,238,.10) 1px,
          transparent 55px,
          transparent 95px
        );
      transform: perspective(900px) rotateX(62deg) translateY(22vh);
      transform-origin: center 65%;
      opacity:.55;
      filter: drop-shadow(0 0 16px rgba(34,211,238,.18));
    }
    .overlay{
      position: fixed;
      inset: 0;
      background:
        radial-gradient(900px 600px at 50% 40%, rgba(255,79,216,.18), transparent 60%),
        radial-gradient(900px 600px at 30% 30%, rgba(34,211,238,.14), transparent 58%),
        linear-gradient(180deg, rgba(0,0,0,.45), rgba(7,0,26,.92));
      color: #e0e7ff;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 50;
    }
    .winner-card{
      background: rgba(34,197,94,.28) !important;
      border: 1px solid rgba(163,230,53,.35) !important;
      box-shadow:
        0 0 18px rgba(163,230,53,.22),
        0 0 30px rgba(34,211,238,.10),
        0 18px 30px rgba(0,0,0,.28) !important;
      color: #eafff1 !important;
    }
    .neonTitle{
      letter-spacing: .02em;
      text-shadow:
        0 0 10px rgba(34,211,238,.35),
        0 0 20px rgba(255,79,216,.25),
        0 0 36px rgba(168,85,247,.18);
    }
    .chrome{
      background: linear-gradient(180deg, #f8fafc 0%, #dbeafe 18%, #93c5fd 35%, #f8fafc 55%, #cbd5e1 80%, #f8fafc 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      filter: drop-shadow(0 0 12px rgba(34,211,238,.20));
    }
    @keyframes headerPulse {
      0%, 100% { filter: drop-shadow(0 0 12px rgba(34,211,238,.20)); }
      50% { filter: drop-shadow(0 0 24px rgba(34,211,238,.45)) drop-shadow(0 0 36px rgba(255,79,216,.25)); }
    }
    header .chrome { animation: headerPulse 2.5s ease-in-out infinite; }
    .subGlow{ text-shadow: 0 0 10px rgba(34,211,238,.25); }
    .glass{
      background: var(--glass);
      border: 1px solid rgba(34,211,238,.18);
      box-shadow:
        0 10px 30px rgba(0,0,0,.25),
        0 0 18px rgba(255,79,216,.10);
      backdrop-filter: blur(10px);
    }
    .glassStrong{
      background: var(--glass2);
      border: 1px solid rgba(255,79,216,.18);
      box-shadow:
        0 12px 34px rgba(0,0,0,.30),
        0 0 22px rgba(34,211,238,.12);
      backdrop-filter: blur(12px);
    }
    .neonBtn{
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
      transition: transform .08s ease, box-shadow .12s ease, filter .12s ease;
      color: #fff;
      font-weight: bold;
    }
    .neonBtn:hover:not(:disabled){
      transform: translateY(-1px);
      box-shadow:
        0 14px 26px rgba(0,0,0,.22),
        0 0 18px rgba(34,211,238,.18),
        0 0 18px rgba(255,79,216,.12);
      filter: saturate(1.15);
    }
    .neonBtn:active:not(:disabled){ transform: translateY(0px) scale(.99); }
    .neonBtn:disabled{
      opacity: .5;
      cursor: not-allowed;
      transform: none;
    }
    .neonPrimary{ background: linear-gradient(90deg, #22d3ee, #a855f7); }
    .neonWarn{ background: linear-gradient(90deg, #ff4fd8, #ef4444); }
    .neonGo{ background: linear-gradient(90deg, #a3e635, #22d3ee); }
    .neonAlt{ background: linear-gradient(90deg, #60a5fa, #22d3ee); }
    .matchCard{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow:
        inset 0 0 0 1px rgba(34,211,238,.10),
        0 10px 25px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
    }
    .matchCard .courtTitle{ text-shadow: 0 0 10px rgba(34,211,238,.18); }
    .winner-button {
      background: linear-gradient(135deg, #22c55e, #16a34a) !important;
      border: 2px solid rgba(34,197,94,.8) !important;
      box-shadow: 0 0 15px rgba(163,230,53,.5) !important;
      transform: scale(1.05) !important;
      color: white !important;
    }
    .winter-text { font-family: 'Fredoka One', cursive; }
    .winter-header { font-family: 'Righteous', cursive; }
    .bold-text { font-family: 'Bungee', cursive; }
  </style>
</head>
<body class="min-h-screen flex flex-col text-white relative">
<div id="bgFX"></div>

<header class="text-center py-6 relative z-10">
  <h1 class="text-5xl font-extrabold winter-header neonTitle chrome" id="headerTitle">Pickleball Event Maker</h1>
  <div class="text-center text-sm mt-1 text-slate-300 subGlow" id="headerSubtitle"></div>
  <span class="header-rule hidden" id="headerRule"></span>
</header>

<div id="setupPanel" class="glassStrong p-6 rounded-lg max-w-4xl mx-auto mb-4 relative z-10">
    <h3 class="text-2xl font-semibold mb-4 text-center winter-text subGlow">Tournament Setup</h3>
  <div class="grid grid-cols-2 gap-4 mb-6">
    <div>
      <label class="block mb-1 winter-text text-cyan-200">Event Name</label>
      <input type="text" id="eventName" value="Highlander Pickleball" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400 focus:ring-1 focus:ring-cyan-400" />
    </div>
    <div>
      <label class="block mb-1 winter-text text-cyan-200">Team Mode</label>
      <select id="modeSelect" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" onchange="onModeChange()">
        <option value="set_teams">Set Teams (fixed)</option>
        <option value="random_pairs">Random Teams (Highlander)</option>
      </select>
    </div>
    <div id="teamCountRow">
      <label class="block mb-1 winter-text text-cyan-200">Number of Teams</label>
      <input type="number" id="teamCount" value="12" min="4" max="14" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" onchange="renderNameInputsDynamic()" />
    </div>
    <div id="playerCountRow" class="hidden">
      <label class="block mb-1 winter-text text-cyan-200">Number of Players</label>
      <input type="number" id="playerCount" value="8" min="4" max="24" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" onchange="renderNameInputsDynamic()" />
    </div>
    <div>
      <label class="block mb-1 winter-text text-cyan-200">Number of Courts</label>
      <input type="number" id="courtCount" value="6" min="1" max="6" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" />
    </div>
    <div>
      <label class="block mb-1 winter-text text-cyan-200">Number of Rounds (0 = Unlimited)</label>
      <input type="number" id="totalRounds" value="11" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" />
    </div>
    <div>
      <label class="block mb-1 winter-text text-cyan-200">Round Duration (minutes)</label>
      <input type="number" id="roundDuration" value="15" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" />
    </div>
    <div>
      <label class="block mb-1 winter-text text-cyan-200">Countdown Before Start (seconds)</label>
      <input type="number" id="countdownDuration" value="90" class="p-2 rounded text-black w-full border border-cyan-400/50 bg-white/10 focus:border-cyan-400" />
    </div>
  </div>
  <div class="mb-6 flex items-center gap-2">
    <input type="checkbox" id="fullscreenToggle" class="w-5 h-5 accent-cyan-400" />
    <label for="fullscreenToggle" class="text-lg winter-text text-cyan-200">Enable Full Screen Mode during rounds</label>
  </div>
  <div id="stormSoundRow" class="mb-6 flex items-center gap-2 hidden">
    <input type="checkbox" id="stormSoundToggle" class="w-5 h-5 accent-amber-500" />
    <label for="stormSoundToggle" class="text-lg winter-text text-amber-200/90">âš¡ Storm Mode Sound (muted by default)</label>
  </div>
  <h4 class="text-xl font-semibold mb-2 text-center winter-text text-cyan-300" id="nameInputsLabel">Team Names</h4>
  <div id="teamInputs" class="flex flex-wrap gap-2 justify-center mb-4"></div>
  <div class="text-center">
    <button onclick="createTournament()" class="neonBtn neonPrimary px-8 py-4 rounded-full font-bold text-xl">
      Create Tournament
    </button>
  </div>
</div>

<main id="mainPanel" class="hidden flex flex-1 gap-6 px-6 relative z-10">
  <div class="flex-1">
    <div class="text-center text-5xl font-bold my-4 winter-text neonTitle text-cyan-300" id="timer">Ready?</div>
    <div class="text-center space-x-3 mb-6">
      <button id="prevBtn" onclick="previousRound()" class="neonBtn neonAlt px-4 py-2 rounded-full font-bold" disabled>Previous</button>
      <button id="startBtn" onclick="startRound()" class="neonBtn neonPrimary px-4 py-2 rounded-full font-bold">Start Round</button>
      <button id="nextBtn" onclick="nextRound()" class="neonBtn neonPrimary px-4 py-2 rounded-full font-bold" disabled>Next Round</button>
      <button id="endBtn" onclick="confirmEndEvent()" class="neonBtn neonWarn px-4 py-2 rounded-full font-bold text-white">End Event</button>
      <button id="shareBtn" class="neonBtn neonGo px-4 py-2 rounded-full font-bold text-white">Spectator QR Code</button>
    </div>
    <div id="roundStatus" class="text-center mb-4 text-lg winter-text text-yellow-300"></div>
    <div id="repeatPairWarning" class="text-center mb-2 text-amber-400/90 text-sm hidden">âš¡ Pairing constraint exhausted â€” 1 repeat partnership used.</div>
    <h2 class="text-2xl mb-4 winter-text text-cyan-300 subGlow" id="roundNumber">Round 0</h2>
    <div id="courtGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
    <div id="byeTeams" class="mt-6 text-center"></div>
  </div>
  <div id="pairingImpossibleModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-[60] hidden">
    <div class="glassStrong rounded-xl p-8 max-w-md text-center">
      <p class="text-lg mb-4">Pairing algorithm failed â€” this is a bug. Check the console for a debug report (remaining players, legal partner counts, history size).</p>
      <button onclick="document.getElementById('pairingImpossibleModal').classList.add('hidden')" class="neonBtn neonAlt px-6 py-2 rounded-full font-bold">OK</button>
    </div>
  </div>
  <div id="leaderboardPanel" class="w-1/3 glassStrong p-4 rounded-lg">
    <h2 class="text-2xl mb-2 winter-text text-cyan-300 subGlow">Leaderboard</h2>
    <div id="leaderboard" class="space-y-2"></div>
  </div>
</main>
<div id="countdownOverlay" class="overlay hidden text-[10rem] font-bold animate-bounce winter-text neonTitle">0</div>
<div id="goOverlay" class="overlay hidden text-[12rem] font-bold winter-text neonTitle" style="color:#ff4fd8;">GO!</div>
<div id="timerOverlay" class="overlay hidden">
  <div id="bigTimer" class="text-[12rem] font-bold mb-12 neonTitle" style="color:#22d3ee;">00:00</div>
  <button id="endRoundBtn" onclick="endRound()" class="neonBtn neonPrimary px-8 py-4 rounded-full text-4xl font-bold hidden">End Round</button>
</div>
<div id="winnerOverlay" class="overlay hidden flex-col text-center">
  <h1 class="text-6xl font-bold mb-6 winter-text neonTitle">Champion: <span id="winnerName"></span></h1>
  <p id="winnerSubtitle" class="text-xl text-cyan-200 mb-4"></p>
  <div id="finalLeaderboard" class="text-3xl"></div>
</div>
<div id="qrOverlay" class="overlay hidden flex-col text-center">
  <h2 class="text-3xl font-bold mb-4 winter-text neonTitle">Scan to View Spectator</h2>
  <div id="qrCodeContainer" class="glass p-4 rounded-xl mb-4">
    <img id="qrCodeImage" src="" alt="Spectator QR Code" class="w-64 h-64" />
  </div>
  <p class="mb-2 text-lg text-cyan-200 subGlow">Spectators scan this to watch live</p>
  <button onclick="copySpectatorLink()" class="neonBtn neonAlt px-4 py-2 rounded-full font-bold">Copy Link</button>
  <button onclick="document.getElementById('qrOverlay').classList.add('hidden')" class="mt-4 text-cyan-300 hover:text-cyan-200 underline">Close</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script src="./pairing.js"></script>
<script>
const urlParams = new URLSearchParams(window.location.search);
const isReadOnly = urlParams.get('view') === 'readonly';
let eventId = urlParams.get('event') || null;

let teams=[], leaderboard=[], matches=[], round=0, config={}, roundRobinSchedule=[];
let timerInterval, timeLeft=0, inProgress=false;
let roundStatus = "idle";
let roundHistory = [];
let allSavedMatches = [];
let currentRoundByes = []; // Random mode: players sitting this round

function updateHeaderForMode() {
  const isHighlander = document.body.classList.contains("highlander");
  const titleEl = document.getElementById("headerTitle");
  const subEl = document.getElementById("headerSubtitle");
  const ruleEl = document.getElementById("headerRule");
  if (isHighlander) {
    titleEl.textContent = "Highlander Pickleball";
    if (subEl) { subEl.textContent = "THERE CAN BE ONLY ONE"; subEl.classList.remove("hidden"); }
    if (ruleEl) { ruleEl.classList.remove("hidden"); }
  } else {
    titleEl.textContent = eventId && window.event ? window.event.name : "Pickleball Event Maker";
    if (subEl) { subEl.textContent = ""; subEl.classList.add("hidden"); }
    if (ruleEl) ruleEl.classList.add("hidden");
  }
}

async function init() {
  if (eventId) {
    await loadEvent();
    document.getElementById("setupPanel").classList.add("hidden");
    document.getElementById("mainPanel").classList.remove("hidden");
    document.title = event.name;
    updateHeaderForMode();
    renderUI();
    updateButtonStates();
    if (isReadOnly) {
      disableButtons();
    }
  } else {
    onModeChange();
    renderNameInputsDynamic();
  }
  document.getElementById('shareBtn').addEventListener('click',()=>{
    if (!eventId) return;
    const link=`${window.location.origin}/spectator.html?event=${eventId}`;
    document.getElementById('qrCodeImage').src=`https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${encodeURIComponent(link)}`;
    document.getElementById('qrOverlay').classList.remove('hidden');
  });
  var stormToggle = document.getElementById('stormSoundToggle');
  if (stormToggle) stormToggle.addEventListener('change', function() { if (config && config.mode === 'random_pairs') config.stormSound = this.checked; });
}

function copySpectatorLink() {
  const link=`${window.location.origin}/spectator.html?event=${eventId}`;
  navigator.clipboard.writeText(link).then(()=>alert('Link copied!'));
}

function disableButtons(){
  document.querySelectorAll("button").forEach(b=>{
    if(b.id!=="shareBtn") b.disabled=true;
  });
}

function getMode(){ return document.getElementById("modeSelect").value; }
function onModeChange(){
  const mode = getMode();
  const teamCountRow = document.getElementById("teamCountRow");
  const playerCountRow = document.getElementById("playerCountRow");
  const labelEl = document.getElementById("nameInputsLabel");
  const stormRow = document.getElementById("stormSoundRow");
  if (mode === "random_pairs") {
    teamCountRow.classList.add("hidden");
    playerCountRow.classList.remove("hidden");
    if (stormRow) stormRow.classList.remove("hidden");
    labelEl.textContent = "Player Names";
    document.body.classList.add("highlander");
  } else {
    teamCountRow.classList.remove("hidden");
    playerCountRow.classList.add("hidden");
    if (stormRow) stormRow.classList.add("hidden");
    labelEl.textContent = "Team Names";
    document.body.classList.remove("highlander");
  }
  renderNameInputsDynamic();
}
function renderNameInputsDynamic(){
  const mode = getMode();
  const count = mode === "random_pairs"
    ? parseInt(document.getElementById("playerCount").value) || 8
    : parseInt(document.getElementById("teamCount").value) || 12;
  const container = document.getElementById("teamInputs");
  container.innerHTML = "";
  const defaultTeams = ["Every Dink You Take", "The Karate Dinks", "Hit Me With Your Best Shot", "My Little Pony", "Purple Pain", "Sweet Dinks are Made of These", "Ghostbusters", "Weekend at Ernies", "Rolling Dinks", "Cyndi Lobbers", "Antonio Pia", "Neil Jamie"];
  const defaultPlayers = ["Player 1", "Player 2", "Player 3", "Player 4", "Player 5", "Player 6", "Player 7", "Player 8", "Player 9", "Player 10", "Player 11", "Player 12"];
  const defaults = mode === "random_pairs" ? defaultPlayers : defaultTeams;
  for (let i = 0; i < count; i++) {
    const defaultValue = defaults[i] || (mode === "random_pairs" ? `Player ${i+1}` : `Team ${i+1}`);
    const id = mode === "random_pairs" ? `playerInput${i}` : `teamInput${i}`;
    container.innerHTML += `<input type="text" id="${id}" value="${defaultValue}" class="p-2 rounded text-black text-sm border-2 border-cyan-400 focus:border-cyan-300 winter-text min-w-[140px] max-w-[220px]">`;
  }
}

async function createTournament(){
  const eventName = document.getElementById("eventName").value || "Pickleball Event";
  const mode = getMode();
  config = {
    mode: mode,
    courtCount: parseInt(document.getElementById("courtCount").value),
    totalRounds: parseInt(document.getElementById("totalRounds").value),
    roundDuration: parseInt(document.getElementById("roundDuration").value),
    countdownDuration: parseInt(document.getElementById("countdownDuration").value),
    stormSound: document.getElementById("stormSoundToggle")?.checked ?? false
  };
  if (mode === "set_teams") {
    config.teamCount = parseInt(document.getElementById("teamCount").value);
    teams = [];
    for (let i = 0; i < config.teamCount; i++) {
      teams.push(document.getElementById(`teamInput${i}`).value || `Team ${i+1}`);
    }
    leaderboard = teams.map(n => ({ name: n, wins: 0 }));
    roundRobinSchedule = createRoundRobinSchedule(teams);
  } else {
    const playerCount = parseInt(document.getElementById("playerCount").value);
    config.players = [];
    for (let i = 0; i < playerCount; i++) {
      config.players.push({
        id: crypto.randomUUID(),
        name: document.getElementById(`playerInput${i}`).value?.trim() || `Player ${i+1}`,
        wins: 0
      });
    }
    config.partnerHistory = {};
    config.playerByeCounts = {};
    config.playerLastByeRound = {};
    config.players.forEach(p => { config.playerByeCounts[p.id] = 0; config.playerLastByeRound[p.id] = 0; });
    config.repeatPairsUsedTotal = 0;
    config.repeatPairsUsedThisRound = 0;
    teams = config.players.map(p => p.name);
    leaderboard = config.players.map(p => ({ id: p.id, name: p.name, wins: 0 }));
    roundRobinSchedule = [];
  }
  round = 0;
  roundStatus = "idle";
  roundHistory = [];
  const teamsForApi = config.mode === "random_pairs" ? leaderboard.map(p => ({ name: p.name, wins: p.wins })) : leaderboard.map(t => ({ name: t.name, wins: t.wins }));
  const res = await fetch("/.netlify/functions/save-event", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ name: eventName, config, round, status: "idle", teams: teamsForApi }) });
  const data = await res.json();
  eventId = data.eventId;
  round = 1;
  if (mode === "set_teams") {
    let firstMatches = roundRobinSchedule[0] || [];
    matches = assignCourtsToMatches(firstMatches, config.courtCount);
    matches.forEach(m => m.round = round);
  } else {
    const out = PAIRING.generateRandomRoundMatches(config.players, config.courtCount, config, round, { maxRetries: 500, strictNoRepeat: true });
    if (out.impossible) {
      document.getElementById("pairingImpossibleModal").classList.remove("hidden");
      return;
    }
    matches = out.matches;
    config = out.config;
    currentRoundByes = out.byePlayers || [];
    document.getElementById("repeatPairWarning").classList.toggle("hidden", !out.usedRepeat);
  }
  allSavedMatches = JSON.parse(JSON.stringify(matches));
  await saveEvent({ round, status: "idle", matches, config, teams: config.mode === "random_pairs" ? leaderboard.map(p => ({ name: p.name, wins: p.wins })) : leaderboard });
  history.replaceState(null, "", `?event=${eventId}`);
  document.title = eventName;
  document.getElementById("headerTitle").textContent = eventName;
  document.getElementById("setupPanel").classList.add("hidden");
  document.getElementById("mainPanel").classList.remove("hidden");
  if (mode === "random_pairs") document.body.classList.add("highlander");
  renderUI();
  updateButtonStates();
}

function createRoundRobinSchedule(teamList){
  // Standard round-robin: each team plays every other team exactly once
  // Uses circle method where position 0 is fixed and others rotate
  const arr=[...teamList];
  if(arr.length%2!==0) arr.push("BYE");
  const n=arr.length, rounds=n-1, half=n/2, schedule=[];
  
  for(let r=0;r<rounds;r++){
    const roundMatches=[];
    for(let i=0;i<half;i++){
      const t1=arr[i], t2=arr[n-1-i];
      if(t1!=="BYE" && t2!=="BYE") {
        roundMatches.push({team1:t1, team2:t2, winner:null});
      }
    }
    schedule.push(roundMatches);
    // Rotate: keep first element fixed, rotate the rest
    arr.splice(1,0,arr.pop());
  }
  return schedule;
}

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function computeSOS(playerName, allMatches) {
  let sos = 0;
  allMatches.forEach(m => {
    const pair1 = PAIRING.parsePairLabel(m.team1), pair2 = PAIRING.parsePairLabel(m.team2);
    const opponents = pair1.includes(playerName) ? pair2 : pair2.includes(playerName) ? pair1 : null;
    if (opponents) opponents.forEach(opp => { sos += leaderboard.find(t => t.name === opp)?.wins || 0; });
  });
  return sos;
}

function assignCourtsToMatches(matchList, courtCount) {
  // Randomly assign courts to ALL matches; court labels are always 1..N
  const courtNumbers = Array.from({length: courtCount}, (_, i) => i + 1);
  
  // Shuffle the matches themselves so team order is random
  const shuffledMatches = shuffleArray([...matchList]);
  
  // Shuffle courts and assign
  const shuffledCourts = shuffleArray(courtNumbers);
  
  const result = shuffledMatches.map((match, index) => ({
    ...match,
    court: shuffledCourts[index % courtCount]
  }));
  // Sort by court so organizer order matches DB (ORDER BY round, court)
  return result.sort((a, b) => (a.court ?? 0) - (b.court ?? 0));
}

function getHeadToHeadResult(team1, team2) {
  // Returns 1 if team1 beat team2, -1 if team2 beat team1, 0 if no head-to-head or tie
  const allMatches = roundRobinSchedule.flat();
  for (const match of allMatches) {
    if ((match.team1 === team1 && match.team2 === team2) || 
        (match.team1 === team2 && match.team2 === team1)) {
      if (match.winner === team1) return 1;
      if (match.winner === team2) return -1;
      return 0; // No winner yet or tie
    }
  }
  return 0; // No head-to-head match found
}

function canStartRound() {
  // Can only start if we're in idle state
  if (roundStatus !== "idle") return false;
  // For round > 1, check that previous round has all winners entered
  // (This is checked when transitioning to next round, so if we're idle, we're good)
  return true;
}

function allWinnersEntered() {
  // Check if all current matches have winners
  const activeMatches = matches.slice(0, config.courtCount);
  return activeMatches.every(m => m.winner !== null);
}

function canGoToNextRound() {
  if (roundStatus !== "completed") return false;
  if (!allWinnersEntered()) return false;
  if (config.mode === "random_pairs") {
    const maxR = config.totalRounds || 0;
    return maxR === 0 || round < maxR;
  }
  if (round >= roundRobinSchedule.length) return false;
  return true;
}

function canGoToPreviousRound() {
  return round > 1 && roundHistory.length > 0;
}

async function startRound() {
  if (!canStartRound()) {
    if (roundStatus === "completed") {
      alert("Round already played! Enter winners and click 'Next Round' to continue.");
    } else if (roundStatus === "in_progress") {
      alert("Round is already in progress!");
    }
    return;
  }
  
  roundStatus = "countdown";
  updateButtonStates();
  showOverlay("countdownOverlay");
  const now = new Date().toISOString();
  await saveEvent({ status: "countdown", countdown_start: now });
  let countdown = config.countdownDuration;
  document.getElementById("countdownOverlay").textContent = countdown;
  const countdownInterval = setInterval(() => {
    countdown--;
    document.getElementById("countdownOverlay").textContent = countdown;
    if (countdown <= 0) {
      clearInterval(countdownInterval);
      hideOverlays();
      showOverlay("goOverlay");
      setTimeout(() => {
        hideOverlays();
        beginTimer();
      }, 2000);
    }
  }, 1000);
}


function playRoundStartSound() {
  try {
    var a = new Audio("onlyone.m4a");
    a.volume = 1.0;
    a.play().catch(function () {});
  } catch (_) {}
}

async function beginTimer(){
  playRoundStartSound();
  inProgress=true;
  roundStatus = "in_progress";
  updateButtonStates();
  timeLeft=config.roundDuration*60;
  await saveEvent({status:"in_progress",current_round_start:new Date().toISOString()});
  showOverlay("timerOverlay");
  document.getElementById("endRoundBtn").classList.remove("hidden");
  startTimer();
}

function startTimer(){
  clearInterval(timerInterval);
  timerInterval=setInterval(()=>{
    if(timeLeft<=0){endRound();}
    document.getElementById("bigTimer").textContent=formatTime(timeLeft);
    timeLeft--;
  },1000);
}

async function endRound(){
  clearInterval(timerInterval);
  inProgress=false;
  roundStatus = "completed";
  hideOverlays();
  document.getElementById("timer").textContent="Enter Winners";
  await saveEvent({status:"completed"});
  updateButtonStates();
}

function updateButtonStates() {
  const startBtn = document.getElementById("startBtn");
  const nextBtn = document.getElementById("nextBtn");
  const prevBtn = document.getElementById("prevBtn");
  const statusDiv = document.getElementById("roundStatus");
  
  // Start button - only enabled in idle state
  if (canStartRound()) {
    startBtn.disabled = false;
    startBtn.classList.remove("opacity-50");
  } else {
    startBtn.disabled = true;
    startBtn.classList.add("opacity-50");
  }
  
  // Next button - only enabled after round completed AND all winners entered
  if (canGoToNextRound()) {
    nextBtn.disabled = false;
    nextBtn.classList.remove("opacity-50");
  } else {
    nextBtn.disabled = true;
    nextBtn.classList.add("opacity-50");
  }
  
  // Previous button - only enabled if there's history
  if (canGoToPreviousRound()) {
    prevBtn.disabled = false;
    prevBtn.classList.remove("opacity-50");
  } else {
    prevBtn.disabled = true;
    prevBtn.classList.add("opacity-50");
  }
  
  // Status message
  let statusMsg = "";
  if (roundStatus === "idle") {
    statusMsg = "ðŸ“‹ Ready to start round";
  } else if (roundStatus === "countdown") {
    statusMsg = "â³ Countdown in progress...";
  } else if (roundStatus === "in_progress") {
    statusMsg = "Round in progress...";
  } else if (roundStatus === "completed") {
    if (!allWinnersEntered()) {
      const missing = matches.slice(0, config.courtCount).filter(m => !m.winner).length;
      statusMsg = `âš ï¸ Enter ${missing} winner(s) to continue`;
    } else {
      statusMsg = "âœ… All winners entered! Click 'Next Round' to continue";
    }
  }
  statusDiv.textContent = statusMsg;
}

async function nextRound(){
  if (!canGoToNextRound()) {
    if (roundStatus !== "completed") {
      alert("You must play the round first! Click 'Start Round'.");
    } else if (!allWinnersEntered()) {
      alert("Please enter all match winners before proceeding.");
    }
    return;
  }
  
  roundHistory.push({
    round: round,
    matches: JSON.parse(JSON.stringify(matches)),
    leaderboard: JSON.parse(JSON.stringify(leaderboard)),
    configSnapshot: config.mode === "random_pairs" ? { partnerHistory: { ...(config.partnerHistory || {}) }, playerByeCounts: { ...(config.playerByeCounts || {}) }, playerLastByeRound: { ...(config.playerLastByeRound || {}) } } : undefined
  });
  
  round++;
  roundStatus = "idle";
  
  if (config.mode === "random_pairs") {
    const out = PAIRING.generateRandomRoundMatches(config.players, config.courtCount, config, round, { maxRetries: 500, strictNoRepeat: true });
    if (out.impossible) {
      document.getElementById("pairingImpossibleModal").classList.remove("hidden");
      return;
    }
    matches = out.matches;
    config = out.config;
    currentRoundByes = out.byePlayers || [];
    document.getElementById("repeatPairWarning").classList.toggle("hidden", !out.usedRepeat);
    allSavedMatches.push(...JSON.parse(JSON.stringify(matches)));
    document.getElementById("timer").textContent = "Ready?";
    await saveEvent({ round, status: "idle", matches, teams: leaderboard.map(p => ({ name: p.name, wins: p.wins })), config });
  } else {
    const savedMatchesForRound = allSavedMatches.filter(m => m.round === round);
    if (savedMatchesForRound.length > 0) {
      matches = JSON.parse(JSON.stringify(savedMatchesForRound));
    } else {
      let nextMatches = roundRobinSchedule[round - 1] || [];
      matches = assignCourtsToMatches(nextMatches, config.courtCount);
      matches.forEach(m => m.round = round);
      allSavedMatches.push(...JSON.parse(JSON.stringify(matches)));
    }
    currentRoundByes = [];
    document.getElementById("timer").textContent = "Ready?";
    await saveEvent({ round, status: "idle", matches, teams: leaderboard });
  }
  renderUI();
  updateButtonStates();
}

async function previousRound() {
  if (!canGoToPreviousRound()) {
    alert("Cannot go back - no previous round available.");
    return;
  }
  
  // Restore previous round state
  const prevState = roundHistory.pop();
  round = prevState.round;
  matches = JSON.parse(JSON.stringify(prevState.matches));
  
  // Update allSavedMatches to reflect the restored round
  allSavedMatches = allSavedMatches.filter(m => m.round !== round);
  allSavedMatches.push(...JSON.parse(JSON.stringify(matches)));
  
  if (prevState.leaderboard) {
    leaderboard = JSON.parse(JSON.stringify(prevState.leaderboard));
  } else {
    recalculateLeaderboard();
  }
  if (config.mode === "random_pairs" && prevState.configSnapshot) {
    config.partnerHistory = prevState.configSnapshot.partnerHistory;
    config.playerByeCounts = prevState.configSnapshot.playerByeCounts;
    config.playerLastByeRound = prevState.configSnapshot.playerLastByeRound;
  }
  roundStatus = "completed";
  if (config.mode !== "random_pairs") {
    for (const match of matches) updateRoundRobinScheduleMatch(match.team1, match.team2, match.winner);
  }
  if (config.mode === "random_pairs") {
    const playing = new Set();
    matches.forEach(m => { PAIRING.parsePairLabel(m.team1).forEach(p => playing.add(p)); PAIRING.parsePairLabel(m.team2).forEach(p => playing.add(p)); });
    currentRoundByes = (config.players || teams).filter(p => !playing.has(p));
  }
  document.getElementById("timer").textContent="Enter Winners";
  await saveEvent({ round, status:"completed", matches, teams: leaderboard, config: config.mode === "random_pairs" ? config : undefined });
  renderUI();
  updateButtonStates();
}

function recalculateLeaderboard() {
  leaderboard.forEach(t => t.wins = 0);
  if (config.mode === "random_pairs") {
    allSavedMatches.forEach(m => {
      if (m.winner) applyPairWins(m.winner, 1);
    });
  } else {
    const allMatches = roundRobinSchedule.flat();
    for (const match of allMatches) {
      if (match.winner) {
        const team = leaderboard.find(t => t.name === match.winner);
        if (team) team.wins++;
      }
    }
  }
}

function confirmEndEvent() {
  if (confirm("Are you sure you want to end the event? This action cannot be undone.")) {
    endEvent();
  }
}

async function endEvent() {
  if (config.mode === "random_pairs") {
    leaderboard.sort((a, b) => b.wins - a.wins);
    const topWins = leaderboard[0].wins;
    const tied = leaderboard.filter(t => t.wins === topWins);
    if (tied.length > 1) {
      const names = tied.map(t => t.name);
      names.sort((a, b) => computeSOS(b, allSavedMatches) - computeSOS(a, allSavedMatches));
      const bestSOS = computeSOS(names[0], allSavedMatches);
      const coChampNames = names.filter(n => computeSOS(n, allSavedMatches) === bestSOS);
      if (coChampNames.length > 1) {
        config.finalWinners = tied.filter(t => coChampNames.includes(t.name)).map(t => t.id);
        config.finalWinnerNames = coChampNames;
        await saveEvent({ status: "event_done", config, teams: leaderboard.map(p => ({ name: p.name, wins: p.wins })) });
        document.getElementById("winnerName").textContent = coChampNames.join(" & ");
        const subEl = document.getElementById("winnerSubtitle");
        if (subEl) subEl.textContent = "THERE CAN BE ONLY ONEâ€¦ BUT TONIGHT WE HAVE LEGENDS.";
        document.getElementById("finalLeaderboard").innerHTML = leaderboard.map((t, i) => `<div>${i + 1}. ${t.name} - ${t.wins}</div>`).join("");
        showWinnerOverlay();
        return;
      }
    }
    leaderboard.sort((a, b) => b.wins - a.wins);
    config.finalWinners = [leaderboard[0].id];
    config.finalWinnerNames = [leaderboard[0].name];
  } else {
    leaderboard.sort((a, b) => {
      if (b.wins !== a.wins) return b.wins - a.wins;
      return getHeadToHeadResult(b.name, a.name);
    });
  }
  const extra = { status: "event_done" };
  if (config.mode === "random_pairs") extra.config = config, extra.teams = leaderboard.map(p => ({ name: p.name, wins: p.wins }));
  await saveEvent(extra);
  document.getElementById("winnerName").textContent = leaderboard[0].name;
  const subEl = document.getElementById("winnerSubtitle");
  if (subEl) subEl.textContent = "";
  showWinnerOverlay();
}

function playStormRumble() {
  if (!config.stormSound) return;
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    const ctx = new Ctx();
    function play() {
      const buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.2));
      const src = ctx.createBufferSource();
      src.buffer = buf;
      const gain = ctx.createGain();
      gain.gain.value = 0.22;
      src.connect(gain);
      gain.connect(ctx.destination);
      src.start(0);
    }
    if (ctx.state === "suspended") ctx.resume().then(play).catch(function () {});
    else play();
  } catch (_) {}
}

function showWinnerOverlay() {
  hideOverlays();
  const nameEl = document.getElementById("winnerName");
  const subEl = document.getElementById("winnerSubtitle");
  const isHighlander = document.body.classList.contains("highlander");
  if (config.finalWinnerNames && config.finalWinnerNames.length > 0) {
    nameEl.textContent = config.finalWinnerNames.join(" & ");
    if (subEl) subEl.textContent = config.finalWinnerNames.length > 1 ? "THERE CAN BE ONLY ONEâ€¦ BUT TONIGHT WE HAVE LEGENDS." : "CHAMPION";
  } else {
    nameEl.textContent = leaderboard[0] ? leaderboard[0].name : "";
    if (subEl) subEl.textContent = "";
  }
  const lb = document.getElementById("finalLeaderboard");
  lb.classList.remove("finalLeaderboard-cols-2", "finalLeaderboard-cols-3");
  if (leaderboard.length > 16) lb.classList.add("finalLeaderboard-cols-3");
  else if (leaderboard.length > 8) lb.classList.add("finalLeaderboard-cols-2");
  lb.innerHTML = leaderboard.map((t, i) => `<div>${i + 1}. ${t.name} - ${t.wins}</div>`).join("");
  if (isHighlander) {
    nameEl.classList.add("winner-name-cinematic");
    playStormRumble();
    setTimeout(function () { showOverlay("winnerOverlay"); }, 450);
  } else {
    nameEl.classList.remove("winner-name-cinematic");
    launchConfetti();
    showOverlay("winnerOverlay");
  }
}

    function launchConfetti() {
      const duration = 4000, end = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 9999, colors: ['#22d3ee', '#f72585', '#a855f7', '#a3e635', '#60a5fa'] };
      const interval = setInterval(() => {
        const timeLeft = end - Date.now();
        if (timeLeft <= 0) return clearInterval(interval);
        const particleCount = 50 * (timeLeft / duration);
        confetti({ ...defaults, particleCount, origin: { x: Math.random() * 0.5, y: Math.random() - 0.2 } });
        confetti({ ...defaults, particleCount, origin: { x: Math.random() * 0.5 + 0.5, y: Math.random() - 0.2 } });
      }, 250);
    }

function applyPairWins(pairLabel, delta) {
  const names = PAIRING.parsePairLabel(pairLabel);
  names.forEach(name => {
    const entry = leaderboard.find(t => t.name === name);
    if (entry) entry.wins += delta;
  });
}

async function recordWin(index,teamName){
  if(isReadOnly)return;
  const match=matches[index];
  if(match.winner === teamName) {
    if (config.mode === "random_pairs") {
      applyPairWins(teamName, -1);
    } else {
      const prevTeam = leaderboard.find(t => t.name === match.winner);
      if(prevTeam) prevTeam.wins--;
      updateRoundRobinScheduleMatch(match.team1, match.team2, null);
    }
    match.winner = null;
  } else {
    if (config.mode === "random_pairs") {
      if (match.winner) applyPairWins(match.winner, -1);
      applyPairWins(teamName, 1);
    } else {
      if(match.winner) {
        const prevTeam = leaderboard.find(t => t.name === match.winner);
        if(prevTeam) prevTeam.wins--;
      }
      match.winner = teamName;
      const team = leaderboard.find(t => t.name === teamName);
      if(team) team.wins++;
      updateRoundRobinScheduleMatch(match.team1, match.team2, teamName);
    }
    match.winner = teamName;
  }
  const matchIndex = allSavedMatches.findIndex(m => 
    m.round === round && 
    ((m.team1 === match.team1 && m.team2 === match.team2) || 
     (m.team1 === match.team2 && m.team2 === match.team1))
  );
  if (matchIndex !== -1) allSavedMatches[matchIndex] = {...match};
  await saveEvent({matches, teams: leaderboard});
  renderUI();
  updateButtonStates();
}

function updateRoundRobinScheduleMatch(team1, team2, winner) {
  // Update the corresponding match in roundRobinSchedule with the winner
  const allMatches = roundRobinSchedule.flat();
  for (const match of allMatches) {
    if ((match.team1 === team1 && match.team2 === team2) || 
        (match.team1 === team2 && match.team2 === team1)) {
      match.winner = winner;
      break;
    }
  }
}

async function saveEvent(extra={}){
  const teamsPayload = (extra.teams !== undefined ? extra.teams : leaderboard).map(t => typeof t === "object" && t != null && "name" in t ? { name: t.name, wins: t.wins ?? 0 } : { name: String(t), wins: 0 });
  const payload = { eventId, name: document.title, config, round, ...extra, teams: teamsPayload, matches };
  await fetch("/.netlify/functions/save-event", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
}

async function loadEvent(){
  const res=await fetch(`/.netlify/functions/load-event?event=${eventId}`);
  if(res.ok){
    const data=await res.json();window.event=data.event;
    config = data.event.config || {};
    round = data.event.round;
    allSavedMatches = data.matches || [];
    matches = allSavedMatches.filter(m=>m.round===round);
    if (config.mode === "random_pairs") {
      const players = config.players || [];
      if (players.length && typeof players[0] === "object" && players[0].id) {
        leaderboard = players.map(p => ({ id: p.id, name: p.name, wins: (data.teams.find(t => t.name === p.name))?.wins ?? p.wins ?? 0 }));
      } else {
        const names = players.length ? players : data.teams.map(t => t.name);
        leaderboard = names.map((n, idx) => ({ id: crypto.randomUUID(), name: typeof n === "string" ? n : n.name, wins: (data.teams.find(t => t.name === (typeof n === "string" ? n : n.name)))?.wins ?? 0 }));
        config.players = leaderboard.map(p => ({ ...p }));
      }
      teams = leaderboard.map(p => p.name);
      roundRobinSchedule = [];
      document.body.classList.add("highlander");
      const playingIds = new Set();
      matches.forEach(m => {
        PAIRING.parsePairLabel(m.team1).concat(PAIRING.parsePairLabel(m.team2)).forEach(name => {
          const pl = config.players.find(p => p.name === name);
          if (pl && pl.id) playingIds.add(pl.id);
        });
      });
      currentRoundByes = (config.players || []).filter(p => !playingIds.has(p.id));
    } else {
      leaderboard = data.teams.map(t => ({ name: t.name, wins: t.wins }));
      teams = data.teams.map(t => t.name);
      roundRobinSchedule = createRoundRobinSchedule(teams);
      document.body.classList.remove("highlander");
      currentRoundByes = [];
    }
    const loadedStatus = data.event.status;
    roundStatus = (loadedStatus === "idle" || loadedStatus === "countdown" || loadedStatus === "in_progress" || loadedStatus === "completed") ? loadedStatus : "idle";
    if (config.mode !== "random_pairs") {
      for (const loadedMatch of allSavedMatches) {
        if (loadedMatch.winner) updateRoundRobinScheduleMatch(loadedMatch.team1, loadedMatch.team2, loadedMatch.winner);
      }
    }
    roundHistory = [];
    for (let r = 1; r < round; r++) {
      const roundMatches = allSavedMatches.filter(m => m.round === r);
      if (roundMatches.length > 0) roundHistory.push({ round: r, matches: roundMatches, leaderboard: null });
    }
    updateButtonStates();
    updateHeaderForMode();
    var stormToggle = document.getElementById('stormSoundToggle');
    if (stormToggle && config.mode === 'random_pairs') stormToggle.checked = !!config.stormSound;
    if (loadedStatus === "event_done") showWinnerOverlay();
  }
}

function showOverlay(id){document.getElementById(id).classList.remove("hidden");}
function hideOverlays(){document.querySelectorAll(".overlay").forEach(el=>el.classList.add("hidden"));}
function renderUI(){
  document.getElementById("roundNumber").textContent=`Round ${round} of ${config.totalRounds||"âˆž"}`;
  const lb=document.getElementById("leaderboard");lb.innerHTML="";
  const sorted = leaderboard.slice().sort((a,b) => {
    if (b.wins !== a.wins) return b.wins - a.wins;
    if (config.mode === "random_pairs") return 0;
    return getHeadToHeadResult(b.name, a.name);
  });
  const topWins = sorted[0] ? sorted[0].wins : 0;
  const tiedLeaders = sorted.filter(t => t.wins === topWins);
  sorted.forEach(t => {
    const rowClass = document.body.classList.contains("highlander") && tiedLeaders.some(x => (x.id || x.name) === (t.id || t.name)) ? "leaderboard-row tied-leader flex justify-between text-sm gap-2 py-1 border-b border-amber-500/20" : "leaderboard-row flex justify-between text-sm gap-2 py-1" + (document.body.classList.contains("highlander") ? " border-b border-amber-500/10" : "");
    const winsClass = document.body.classList.contains("highlander") ? "wins-num shrink-0" : "shrink-0";
    lb.innerHTML += `<div class="${rowClass}"><span class="truncate min-w-0">${t.name}</span><span class="${winsClass}">${t.wins}</span></div>`;
  });
  const grid=document.getElementById("courtGrid");grid.innerHTML="";
  const courts=config.courtCount||3;
  const displayedMatches = matches.slice(0, courts);
  const toRoman = (n) => { const r = ["","I","II","III","IV","V","VI","VII","VIII","IX","X"]; return n >= 1 && n <= 10 ? r[n] : String(n); };
  displayedMatches.forEach((m,i)=>{
    if (m.court === undefined || m.court === null) throw new Error("Match missing court");
    const courtLabel = document.body.classList.contains("highlander") ? ("COURT " + toRoman(m.court)) : m.court;
    const winnerClass=m.winner?'winner-card':'winter-card';
    const team1Escaped = (m.team1 || "").replace(/'/g, "\\'");
    const team2Escaped = (m.team2 || "").replace(/'/g, "\\'");
    grid.innerHTML+=`<div class="matchCard rounded-lg p-4 text-center ${winnerClass} text-white">
      <div class="courtTitle font-bold mb-2 winter-text text-lg">${courtLabel}</div>
      <div class="text-sm font-semibold leading-tight">${m.team1} vs ${m.team2}</div>
      <div class="mt-2 winter-text text-sm">Winner: ${m.winner||'TBD'}</div>
      ${!isReadOnly?`<div class="mt-2 flex flex-wrap gap-1 justify-center">
        <button onclick="recordWin(${i},'${team1Escaped}')" class="neonBtn neonAlt px-2 py-1 rounded-full text-xs leading-tight text-center ${m.winner === m.team1 ? 'winner-button' : ''}">${m.team1}</button>
        <button onclick="recordWin(${i},'${team2Escaped}')" class="neonBtn neonAlt px-2 py-1 rounded-full text-xs leading-tight text-center ${m.winner === m.team2 ? 'winner-button' : ''}">${m.team2}</button>
      </div>`:''}
    </div>`;
  });
  const byeTeamsElement = document.getElementById("byeTeams");
  let byeList = [];
  if (config.mode === "random_pairs") {
    byeList = (currentRoundByes || []).map(p => typeof p === "object" && p != null && p.name != null ? p.name : String(p));
  } else {
    byeList = teams.filter(team => !displayedMatches.flatMap(m => [m.team1, m.team2]).includes(team));
  }
  if (byeList.length > 0) {
    byeTeamsElement.innerHTML = `<div class="winter-text text-cyan-300 text-sm subGlow">BYE / Rest: ${byeList.join(", ")}</div>`;
  } else {
    byeTeamsElement.textContent = "";
  }
}
function formatTime(s){const m=Math.floor(s/60),sec=Math.floor(s%60);return `${m}:${sec<10?"0":""}${sec}`;}
init();
</script>
</body>
</html>
